# 6.5. CSS3-анимация

Мы недавно видели, что переходы \(`transition`\)— это просто способ анимации стилевых свойств от исходного до конечного состояния.Итак, переходы\(`transition`\) в 

**CSS являются специфическим видом анимации,** где:

 1\) есть только два состояния: начало и конец;

2\) анимация не зациклена;

3\) промежуточные состояния управляются только функцией времени.



Но что если вы хотите:

* иметь контроль над промежуточными состояниями?
* зациклить анимацию?
* сделать разные виды анимаций для одного элемента?
* анимировать определённое свойство только на половину пути?
* имитировать различные функции времени для разных свойств?

Анимация в CSS позволяет всё это, и не только!

Анимация как мини-фильм, где вы в качестве режиссёра даёте инструкции \(стилевые правила\) вашим актёрам \(элементам HTML\) для разных сцен \(ключевые кадры\). CSS3-анимация может применяться практически для всех html-элементов, а также для псевдоэлементов `:before` и `:after`. 

При создании анимации не стоит забывать о возможных проблемах с производительностью, так как на изменение некоторых свойств требуется много ресурсов.

#### Свойства анимации <a id="h3-19"></a>

Как и `transition`, свойство `animation` является сокращённым для нескольких других:

|  | "" |
| :--- | :--- |
| `animation-name` | название анимации |
| `animation-duration` | "как долго длится анимация" |
| `animation-timing-function` | " как вычисляются промежуточные состояния" |
| `animation-delay` | "анимация начинается спустя некоторое время" |
| `animation-iteration-count` | "сколько раз должна выполняться анимация" |
| `animation-direction` | "должно движение идти в обратную сторону или нет" |
| `animation-fill-mode` | "какие стили применяются до начала анимации и после её завершения" |
|  |  |

Быстрый пример

```text
Для оживления кнопки загрузки, вы можете написать анимацию подпрыгивания:

@keyframes bouncing{
  0%  { bottom: 0; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
  100% { bottom: 50px; box-shadow: 0 50px 50px rgba(0,0,0,0.1); }
}
  
.loading-button { 
 animation: bouncing 0.5s cubic-bezier(0.1,0.25,0.1,1) 0s infinite alternate both; 
}
```

Сначала нужно написать реальную анимацию подпрыгивания с помощью `@keyframes` и назвать её `bouncing`. 

Затем вы можете использовать эту анимацию, применяя её к `.loading-button`

Разберем пример \(тут включены все возможные варианты свойств анимации\):

* `animation-name`: bouncing \(совпадает с названием ключевых кадров\) 
* `animation-duration`: 0.5s \(полсекунды\)
* `animation-timing-function`: cubic-bezier\(0.1,0.25,0.1,1\) 
* `animation-delay`: 0s \(без задержки\) 
* `animation-iteration-count`: infinite \(воспроизводится бесконечно\)
* `animation-direction`: alternate \(идёт назад и вперёд\) 
* `animation-fill-mode`: both

#### @keyframes <a id="keyframes"></a>

Перед применением анимации к элементам HTML, вам требуется написать анимацию с помощью **ключевых кадров**.

**Ключевые кадры** — это каждый промежуточный шаг в анимации. 

Они определяются с помощью процентов:

* [ ] **0%** — первый шаг анимации;
* [ ] **50%** — шаг на полпути в анимации;
* [ ] **100%** — последний шаг.

Можно также использовать ключевые слова `from` и `to` вместо `0%` и `100%`, соответственно.

> Вы можете определить столько ключевых кадров, сколько хотите, вроде 33%, 4% или даже 29.86%. На практике вы будете писать только некоторые из них.

Каждый ключевой кадр является правилом CSS, это означает, что вы можете писать свойства CSS как обычно.

Если 0% или 100% кадры не указаны, то браузер пользователя создает их, используя вычисляемые \(первоначально заданные\) значения анимируемого свойства.

Если несколько правил `@keyframes` определены с одним и тем же именем, сработает последнее в порядке документа, а все предыдущие проигнорируются.

```text
После объявления правила @keyframes, мы можем ссылаться на него в свойстве animation:

h1 {
    font-size: 3.5em;
    color: #000;
    animation: shadow  2s infinite ease-in-out;
}
```

> Не рекомендуется анимировать нечисловые значения \(за редким исключением\), так как результат в браузере может быть непредсказуемым. Также не следует создавать ключевые кадры для значений свойств, не имеющих средней точки, например, для значений свойства color: pink и color: \#ffffff, width: auto и width: 100px или border-radius: 0 и border-radius: 50% \(в этом случае правильно будет указать border-radius: 0%\).

#### `animation-name` <a id="animationname"></a>

Название анимации используется, по крайней мере, дважды: 1\) при написании анимации с помощью @keframes; 2\) при использовании анимации с помощью свойства `animation-name` \(или через сокращённое свойство `animation`\).

```text
@keyframes whatever {
  /* ... */
}
  
.selector { animation-name: whatever; }
```

Подобно именам классов CSS, **название анимации может включать в себя только**: \* буквы \(a-z\);\* цифры \(0-9\);\* подчёркивание \(\_\);\* дефис \(-\).\* название не может начинаться с цифры или с двух дефисов.

#### `animation-duration` <a id="animationduration"></a>

Как и длительность перехода, длительность анимации может быть установлена в секундах \(1s\) или миллисекундах \(200ms\).

```text
.selector { animation-duration: 0.5s; }
```

Значение по умолчанию равно `0s`, что означает отсутствие анимации вообще.

#### `animation-timing-function` <a id="animationtimingfunction"></a>

Подобно функциям времени для переходов, функции времени для анимации могут использовать ключевые слова, такие как `linear`, `ease-out` или могут быть определены с помощью произвольных кривых Безье.

```text
.selector { animation-timing-function: ease-in-out; }
```

Значение по умолчанию: `ease`. Поскольку анимация в CSS использует ключевые кадры, вы можете установить линейную функцию времени и моделировать конкретную кривую Безье, определяя множество очень специфичных ключевых кадров. Посмотрите [Bounce.js](http://bouncejs.com/) для создания передовой анимации.

#### `animation-delay` <a id="animationdelay"></a>

Как и с задержкой перехода, задержка анимации может быть установлена в секундах \(1s\) или миллисекундах \(200ms\).По умолчанию равно 0s, что означает отсутствие любой задержки.Полезно использовать, когда включается несколько анимаций в серии.

```text
.a, .b, .c { animation: bouncing 1s; }
.b { animation-delay: 0.25s; }
.c { animation-delay: 0.5s; }
```

#### `animation-iteration-count` <a id="animationiterationcount"></a>

По умолчанию, анимация воспроизводится только один раз \(значение 1\). Вы можете установить три типа значений:

* целые числа, вроде 2 или 3;
* дробные числа, вроде 0.5, которые будут воспроизводить только половину анимации;
* ключевое слово `infinite`, которое будет повторять анимацию бесконечно.

```text
.selector { animation-iteration-count: infinite; }
```

#### `animation-direction` <a id="animationdirection"></a>

Свойство `animation-direction` определяет, в каком порядке читаются ключевые кадры.

* `normal`: начинается с 0%, заканчивается на 100%, начинается с 0% снова.
* `reverse`: начинается со 100%, заканчивается на 0%, начинается со 100% снова.
* `alternate`: начинается с 0%, идёт до 100%, возвращается на 0%.
* `alternate-reverse`: начинается со 100%, идёт до 0%, возвращается на 100%.

Это легче представить, если счётчик итераций анимации установлен как `infinite`.



#### `animation-fill-mode` <a id="animationfillmode"></a>

Свойство `animation-fill-mode` определяет, что происходит перед началом анимации и после её завершения.При определении ключевых кадров можно указать правила CSS, которые будут применяться на разных шагах анимации.Теперь эти правила CSS могут столкнуться с теми, которые уже применяются к анимируемым элементам.`animation-fill-mode` позволяет сообщить браузеру, если стили анимации также должны применяться за пределами анимации.

